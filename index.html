<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="My blog about programming and machine learning">
<meta name="keywords" content="Machine Learning, Deep Learning, TensorFlow, Python">
<meta property="og:type" content="website">
<meta property="og:title" content="Black Feather">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Black Feather">
<meta property="og:description" content="My blog about programming and machine learning">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Black Feather">
<meta name="twitter:description" content="My blog about programming and machine learning">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>Black Feather</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Black Feather</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/07/13/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/13/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-13T21:18:56+09:00">
                2018-07-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/05/21/Scheme语言基本语法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/21/Scheme语言基本语法/" itemprop="url">Scheme基本语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-21T00:00:00+09:00">
                2018-05-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本篇介绍对Scheme函数式编程语言的基础语法学习，因为研究室要进行EOPL（《Essentials of Programming Languages》）的轮讲，而这本书是用Scheme作为教学语言，以至于不得不学习一下Scheme的基本语法。同时作为一种教学性质的函数式编程语言，Scheme语法简单，非常通俗易懂，可以帮助程序员理解函数式编程思想，还是值得一学的。而且著名的编程神书SICP（《Structure and Interpretation of Computer Programs》）也是用Scheme作为教学语言（EOPL的作者是SICP的联合作者之一，都是Scheme的拥簇）。所以为了方便理解这两本书，对Scheme的基本语法有一个简单的了解还是有必要的。</p>
<h2 id="Scheme-Basic"><a href="#Scheme-Basic" class="headerlink" title="Scheme Basic"></a>Scheme Basic</h2><p>与一般的编程语言最大的区别，Scheme使用前缀表达式。什么意思呢，看如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+ 1 2)</span><br><span class="line">(+ 1 2 3 4 5)</span><br></pre></td></tr></table></figure></p>
<p>上面这行代码就是一句最简单的Scheme程序，返回1+2的结果。可以看到Scheme使用前缀表达式，先输入运算符‘+’，然后输入运算符的两个参数‘1’，‘2’。使用前缀表达式的一个最直接的优点就是运算符的运算对象个数不受限制，我们可以用一个‘+’计算任意个数的和。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul>
<li><p>Scheme使用分号”;”表示单行注释：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; this is a scheme comment</span><br></pre></td></tr></table></figure>
</li>
<li><p>标准Scheme中未定义多行注释方法。</p>
</li>
</ul>
<h3 id="块-form"><a href="#块-form" class="headerlink" title="块(form)"></a>块(form)</h3><ul>
<li><p>块是Scheme中最小单元，用”( )”表示一个form，一个form可以是一个表达式，一个过程，一个变量声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+ 1 2)</span><br><span class="line">(define x 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>块可以通过嵌套完成复杂的表达式计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(+ (* 2 3) (/ 5 (- 3 2)))</span><br><span class="line">; == 2*3 + 5/(3-2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="基本数值运算"><a href="#基本数值运算" class="headerlink" title="基本数值运算"></a>基本数值运算</h3><p>+, -, *, 和/分别代表加、减、乘、除。由于Scheme使用的是前缀表达式，所以这些操作都接受任意多的参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(+ 1 2 3 4) ;→ 10</span><br><span class="line">(- 10 1 2)  ;→ 7</span><br><span class="line">(* 2 3 4)   ;→ 24</span><br><span class="line">(/ 29 3 7)  ;→ 29/21</span><br></pre></td></tr></table></figure></p>
<h3 id="数值运算"><a href="#数值运算" class="headerlink" title="数值运算"></a>数值运算</h3><p>Scheme有很多扩展库定义了一些有用的过程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(max 1 2 3 4)</span><br><span class="line">(min 1 2 3 4)</span><br><span class="line">(abs -2)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>高级编程语言的一个重要特性就是变量，我们可以通过定义变量从而记录对应的数据，进而可以进行更复杂的计算。在Scheme中使用’define’定义一个变量：</p>
<ul>
<li><p>定义一个变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define x 2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用set!来改变变量的值:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(set! x &quot;hello&quot;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Scheme和python一样，它的变量类型是不固定的，可以随时改变。</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h3><ul>
<li>Scheme使用“#t”表示真(True)，使用“#f”表示假(False)</li>
<li><p>“not” 表示取反:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(not #f) -&gt;True</span><br><span class="line">(not 1)  -&gt;False</span><br></pre></td></tr></table></figure>
</li>
<li><p>“not”后面的参数只要不是布尔型，都返回#f</p>
</li>
</ul>
<h3 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h3><p>Scheme支持四种数值类型：整型(integer)，有理数型(rational)，实型(real)，复数型(complex)</p>
<h3 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h3><p>Scheme语言中的字符型数据均以符号组合 “#\” 开始，表示单个字符，可以是字母、数字或”[ ! $ % &amp; * + - . / : %lt; = &gt; ? @ ^ _ ~ ]”等等其它字符，如：</p>
<p>#\A 表示大写字母A，#\0表示字符0，<br>其中特殊字符有：#\space 表示空格符和 #\newline 表示换行符。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串(string) 由多个字符组成的数据类型，可以直接写成由双引号括起的内容，如：”hello” 。</p>
<h3 id="点对-pair"><a href="#点对-pair" class="headerlink" title="点对(pair)"></a>点对(pair)</h3><p>pair是Scheme中非常重要的一个数据结构，它是由一个点和被它分隔开的两个所值组成的。形如： (1 . 2) 或 (a . b) ，注意的是点的两边有空格。<br>它用cons来定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(cons 8 9) =&gt;(8 . 9)</span><br></pre></td></tr></table></figure></p>
<p>其中在点前面的值被称为 car ，在点后面的值被称为 cdr ，car和cdr同时又成为取pair的这两个值的过程，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(define p (cons 4 5))   =&gt; (4 . 5)</span><br><span class="line">(car p)         =&gt; 4</span><br><span class="line">(cdr p)         =&gt; 5</span><br></pre></td></tr></table></figure></p>
<p>还可以用set-car! 和 set-cdr! 来分别设定这两个值：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(set-car! p &quot;hello&quot;)</span><br><span class="line">(set-cdr! p &quot;good&quot;)</span><br></pre></td></tr></table></figure></p>
<h3 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h3><p>Scheme中的列表结构和数据结构中的链表比较相似具体方法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define la (list 1 2 3 4 ))   -&gt;(1 2 3 4)</span><br><span class="line">(length la)  ; 取得列表的长度</span><br><span class="line">(list-ref la 3)  ; 取得列表第3项的值（从0开始）</span><br><span class="line">(list-set! la 2 99)  ; 设定列表第2项的值为99</span><br><span class="line">(define y (make-list 5 6))  ;创建列表</span><br><span class="line">(6 6 6 6 6)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>make-list用来创建列表，第一个参数是列表的长度，第二个参数是列表中添充的内容；还可以实现多重列表，即列表的元素也是列表，如：(list (list 1 2 3) (list 4 5 6))。</li>
<li>列表是在点对的基础上形成的一种特殊格式，所以可以通过pair构建list。用于pair的操作过程大多可以用于list。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(cadr ls)   ; 此&quot;点对&quot;对象的cdr的car</span><br><span class="line">(cddr ls)   ; 此&quot;点对&quot;对象的cdr的cdr</span><br><span class="line">(caddr ls)   ; 此&quot;点对&quot;对象的cdr的cdr的car</span><br><span class="line">(cdddr ls)   ; 此&quot;点对&quot;对象的cdr的cdr的cdr</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="类型判断-转换"><a href="#类型判断-转换" class="headerlink" title="类型判断/转换"></a>类型判断/转换</h3><ul>
<li>Scheme语言中所有判断都是用类型名加问号再加相应的常量或变量构成：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(type? variable)</span><br><span class="line">(boolean? #f)</span><br><span class="line">(char? #\a)</span><br><span class="line">(integer? 1)</span><br><span class="line">(real? 4/5)</span><br><span class="line">(null? &apos;())</span><br></pre></td></tr></table></figure>
<ul>
<li>Scheme中可以使用 “=”, “eq? “, “eqv? “, “equal? “判断是否相等</li>
<li>Scheme使用”-&gt;”表示类型转换：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(number-&gt;string 123)  ; 数字转换为字符串</span><br><span class="line">(string-&gt;number &quot;456&quot;)  ; 字符串转换为数字</span><br><span class="line">(char-&gt;integer #\a)   ;字符转换为整型数，小写字母a的ASCII码值为97</span><br><span class="line">(char-&gt;integer #\A)  ;大写字母A的值为65</span><br><span class="line">(integer-&gt;char 97)  ;整型数转换为字符#\a</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="过程-Procedure"><a href="#过程-Procedure" class="headerlink" title="过程(Procedure)"></a>过程(Procedure)</h2><p>在Scheme语言中，过程相当于C语言中的函数，不同的是Scheme语言过程是一种数据类型，这也是为什么Scheme语言将程序和数据作为同一对象处理的原因。也正是因为如此，define不仅可以定义变量，还可以定义过程，不过标准过程定义要使用lambda关键字来标识。</p>
<h3 id="lambda"><a href="#lambda" class="headerlink" title="lambda"></a>lambda</h3><p>Scheme语言中可以用lambda来定义过程，其格式如下：<br>(define 过程名 ( lambda (参数 …) (操作过程 …)))<br>例：定义自增1的过程 add1：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define add1 (lambda (x) (+ x 1)))</span><br></pre></td></tr></table></figure></p>
<p>该过程需要传入一个参数x，返回x+1的值。</p>
<h3 id="另一种过程定义方法"><a href="#另一种过程定义方法" class="headerlink" title="另一种过程定义方法"></a>另一种过程定义方法</h3><p>在Scheme语言中，也可以不用lambda，而直接用define来定义过程，它的格式为：<br>(define (过程名 参数) (过程内容 …))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(define (add1 x) (+ x 1))</span><br></pre></td></tr></table></figure></p>
<h3 id="过程的嵌套定义"><a href="#过程的嵌套定义" class="headerlink" title="过程的嵌套定义"></a>过程的嵌套定义</h3><p>在Scheme语言中，过程定义也可以嵌套，一般情况下，过程的内部过程定义只有在过程内部才有效，相当C语言中的局部变量。</p>
<h2 id="常用结构"><a href="#常用结构" class="headerlink" title="常用结构"></a>常用结构</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><h4 id="if"><a href="#if" class="headerlink" title="if"></a>if</h4><p>用法如同常规语言，Scheme的具体语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(if (predicate)</span><br><span class="line">    (consequent)</span><br><span class="line">    (alternative))</span><br></pre></td></tr></table></figure></p>
<h4 id="cond"><a href="#cond" class="headerlink" title="cond"></a>cond</h4><p>用法如同C语言中的switch关键字，具体语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(cond</span><br><span class="line">  (predicate1) (consequent1)</span><br><span class="line">  (predicate2) (consequent2)</span><br><span class="line">  ...</span><br><span class="line">  else (consequentn))</span><br><span class="line">; else 可写可不写</span><br></pre></td></tr></table></figure></p>
<h3 id="逻辑判断词"><a href="#逻辑判断词" class="headerlink" title="逻辑判断词"></a>逻辑判断词</h3><p>在Scheme中，使用逻辑关键字and，or，not表示布尔逻辑判断与或非：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(not #f)</span><br><span class="line">(and (#f) (#t))</span><br><span class="line">(or (#f) (#t))</span><br></pre></td></tr></table></figure></p>
<h3 id="case"><a href="#case" class="headerlink" title="case"></a>case</h3><p>case类似于枚举型的cond，具体用法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(case (* 2 4)</span><br><span class="line">  ((1 3 5 7) &apos;odd)</span><br><span class="line">  ((2 4 6 8) &apos;even))</span><br><span class="line">; 结果返回 even</span><br></pre></td></tr></table></figure></p>
<h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><p>在Scheme中， 并没有定义循环关键字，但如同其他高级语言一样，Scheme支持递归调用，所以一般情况下Scheme通过递归来实现循环</p>
<h2 id="变量和过程的绑定"><a href="#变量和过程的绑定" class="headerlink" title="变量和过程的绑定"></a>变量和过程的绑定</h2><p>使用let, let*, letrec在lambda里面定义局部变量。</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(let (x 2) (y 5) (* x y))</span><br></pre></td></tr></table></figure>
<ul>
<li>letrec<br>letrec是将内部定义的过程或变量间的相互引用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(letrec ((countdown</span><br><span class="line">          (lambda (i)</span><br><span class="line">          (if (= i 0)</span><br><span class="line">              &apos;()</span><br><span class="line">              (countdown (- i 1)))))))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><p>apply的功能是为数据赋予某一个操作过程，他的第一个参数必须是一个过程，随后的阐述必须是一个列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(apply + (list 1 2 3))</span><br><span class="line">&gt;&gt; 6</span><br><span class="line"></span><br><span class="line">(define scrum</span><br><span class="line">  (lambda (x)</span><br><span class="line">    (apply + x)))</span><br></pre></td></tr></table></figure></p>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>map的功能和apply有些相似，它的第一个参数也必需是一个过程，随后的参数必需是多个列表，返回的结果是此过程来操作列表后的值</p>
<h2 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h2><h3 id="begin"><a href="#begin" class="headerlink" title="begin"></a>begin</h3><p>通过begin过程实现顺序结构，用begin来将多个form放在一对小括号内，最终形成一个form。格式为：(begin form1 form2 …)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(begin</span><br><span class="line">    (display &quot;hello world&quot;)</span><br><span class="line">    (display &quot;goodbye world&quot;)</span><br><span class="line">    (newline))</span><br></pre></td></tr></table></figure></p>
<h3 id="scheme-quote函数"><a href="#scheme-quote函数" class="headerlink" title="scheme quote函数"></a>scheme quote函数</h3><p>引用（Quotation）</p>
<p>语法：(quote obj) 或者简写为 ‘obj</p>
<p>(+ 2 3)      ; 返回 5<br>‘(+ 2 3)     ; 返回列表 (+ 2 3)<br>(quote (+ 2 3)) ; 返回列表 (+ 2 3)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/27/SICP第二章笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/27/SICP第二章笔记/" itemprop="url">SICP第二章:构造数据抽象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-27T00:00:00+09:00">
                2018-04-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="为什么需要复合数据？"><a href="#为什么需要复合数据？" class="headerlink" title="为什么需要复合数据？"></a>为什么需要复合数据？</h3><p>与我们需要复合过程一样的原因一样：同样是为了提升我们在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。正如定义过程的能力使我们有可能在更高的概念层次上处理计算工作一样，复合数据的能力，也将使我们得以在比语言提供的基本数据对象更高的概念层次上，处理与数据有关的各种问题。</p>
<h3 id="复合数据提高模块性"><a href="#复合数据提高模块性" class="headerlink" title="复合数据提高模块性"></a>复合数据提高模块性</h3><p>如果我们可以直接在将有理数本身当作对象的方式下操作他们，那么也就可能把处理有理数的那些程序部分，与有理数如何表示的细节隔离开。也就是说：将程序中处理数据对象的表示部分，和处理数据对象的使用的部分相互隔离。数据抽象技术能使程序更容易设计，维护和修改。</p>
<h2 id="2-1-数据抽象索引"><a href="#2-1-数据抽象索引" class="headerlink" title="2.1 数据抽象索引"></a>2.1 数据抽象索引</h2><ul>
<li><p>数据抽象使一种方法学，它使我们能将一个 <strong>复合数据对象的使用</strong>，与该数据对象怎样由 <strong>更基本的数据对象构造</strong> 起来的细节隔离开。（对于过程抽象，我们可以理解为：构造一个抽象，它将这一过程的 <strong>使用方式</strong>，和该过程究竟如何通过 <strong>更基本的过程实现的具体细节</strong> 相互分离）  </p>
</li>
<li><p>数据抽象的基本思想，就是设法构造出一些使用复合数据对象的程序。我们的程序使用数据的方式应该是这样的：除了完成当前工作所必要的东西之外，它们不对所有数据作任何假设，与此同时，一种‘具体’数据表示的定义，也应该与程序中使用数据的方式无关。这两个部分之间的界面是一组过程，称为 <strong>选择函数和构造函数</strong></p>
</li>
</ul>
<h3 id="2-1-1-实例：有理数的运算"><a href="#2-1-1-实例：有理数的运算" class="headerlink" title="2.1.1 实例：有理数的运算"></a>2.1.1 实例：有理数的运算</h3><p>假定我们要作有理数的算术，包括加减乘除等<br>假定已经有了一种从分子和分母构造有理数的方法，并进一步假定如果有了一个有理数，我们有一种方法取得他的分子和分母。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(make-rat &lt;n&gt; &lt;d&gt;) 返回一个有理数， 分子是n，分母是d</span><br><span class="line">(numer &lt;x&gt;) 返回分子</span><br><span class="line">(denom &lt;x&gt;) 返回分母</span><br></pre></td></tr></table></figure></p>
<p>目前，我们并不考虑上面的三个过程的具体实现，我们仅根据他们的功能，完成有理数的加减乘除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(define (add-rat x y)</span><br><span class="line">  (make-rat (+ (* (numer x) (denom y))</span><br><span class="line">               (* (numer y) (denom x)))</span><br><span class="line">            (* (denom x) (denom y))))</span><br><span class="line"></span><br><span class="line">(define (sub-rat x y)</span><br><span class="line">  (make-rat (- (* (numer x) (denom y))</span><br><span class="line">               (* (numer y) (denom x)))</span><br><span class="line">            (* (denom x) (denom y))))</span><br><span class="line"></span><br><span class="line">(define (mul-rat x y)</span><br><span class="line">  (make-rat (* (numer x) (numer y))</span><br><span class="line">            (* (denom x) (denom y))))</span><br><span class="line"></span><br><span class="line">(define (div-rat x y)</span><br><span class="line">  (make-rat (* (numer x) (denom y))</span><br><span class="line">            (* (numer y) (denom x))))</span><br><span class="line"></span><br><span class="line">(define (equal-rat? x y)</span><br><span class="line">  (let ((a (* (numer x) (denom y)))</span><br><span class="line">        (b (* (numer y) (denom x))))</span><br><span class="line">    (if (eqv? a b)</span><br><span class="line">        #t</span><br><span class="line">        #f)))</span><br></pre></td></tr></table></figure></p>
<p>这样，我们有了定义在三个构造过程基础之上的各种运算。而这些基础还没有定义。我们可以使用序对cons进行构造：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(define (make-rat n d) (cons n d))</span><br><span class="line">(define (numer x) (car x))</span><br><span class="line">(define (denom x) (cdr x))</span><br><span class="line">(define (print-rat x))</span><br></pre></td></tr></table></figure></p>
<h3 id="2-1-2-抽象屏障"><a href="#2-1-2-抽象屏障" class="headerlink" title="2.1.2 抽象屏障"></a>2.1.2 抽象屏障</h3><ul>
<li>一般而言，数据抽象的基本思想就是为每一类数据对象标示出一组 <strong>基本操作</strong>，使得对这类数据对象的所有操作都可以基于他们表述，而且在操作这些数据对象时也只能使用他们。</li>
<li>对于数据，可以有多个抽象层次，也就是多个抽象屏障，如有理数的定义：<blockquote>
<p>使用有理数的程序将仅仅通过有理数包提供的“API”（add-rat, sub-rat, mul-rat, div-rat..)去完成有理数操作；而这些过程转而又是完全基于构造函数和选择函数make-rat, numer, denom实现的。而这些函数又是基于序对实现的，只要序对可以通过cons,car和cdr操作。，有关序对如何实现的细节与有理数包的其余部分都完全没有关系。</p>
</blockquote>
</li>
</ul>
<h3 id="2-1-3-数据意味着什么"><a href="#2-1-3-数据意味着什么" class="headerlink" title="2.1.3 数据意味着什么"></a>2.1.3 数据意味着什么</h3><ul>
<li>可以考虑 <strong>序对</strong> ，我们从来没有说过序对是什么，只是说所有的语言为序对的操作提供了三个过程cons，car，cdr。有关这三个操作，我们需要知道的全部东西就是，三个过程的功能。</li>
<li><p>进一步思考，我们能发现一个令人吃惊的事实：我们完全可以不用任何数据结构，只使用过程就可以实现序对：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(define (cons x y)</span><br><span class="line">  (define (dispatch m)</span><br><span class="line">    (cond ((= m 0) x)</span><br><span class="line">          ((= m 1) y)</span><br><span class="line">          (else (error &quot;argument no 0 or 1&quot; m))))</span><br><span class="line">  dispatch)</span><br><span class="line">(define (car z) (z 0))</span><br><span class="line">(define (cdr z) (z 1))</span><br><span class="line"></span><br><span class="line">(car (cons 0 1)) -&gt; 0</span><br><span class="line">(cdr (cons 0 1)) -&gt; 1</span><br><span class="line"></span><br><span class="line">; cons过程会返回一个过程，而过程car，cdr会使用cons返回的过程并传入；参数，而在cons返回的过程中针对传入的参数进行操作。</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以看出，cons返回一个过程，而对这三个方法的定义，完全满足了序对的定义。从这个例子可以看出，我们无法把这一实现和“真正的”数据结构区分开。</p>
</li>
<li><strong>数据的过程性表示</strong> 将在我们的程序设计中扮演一种核心角色。有关的程序设计风格通常称为 <strong>消息传递</strong></li>
</ul>
<h2 id="2-2-层次性数据和闭包性质"><a href="#2-2-层次性数据和闭包性质" class="headerlink" title="2.2 层次性数据和闭包性质"></a>2.2 层次性数据和闭包性质</h2><ul>
<li>序对为我们提供了一种用于构造复合数据的基本“粘合剂”。我们可以建立元素本身也是序对的序对，这就是表结构得以作为一种表示工具的根本基础。我们将这种能力成为cons的闭包性质。</li>
<li>一般的说，某种组合数据对象的操作满足闭包性质，那就是说，通过它组合起来的数据对象得到的结果本身还可以通过同样的操作再进行组合。</li>
</ul>
<h3 id="2-2-1-序列的表示"><a href="#2-2-1-序列的表示" class="headerlink" title="2.2.1 序列的表示"></a>2.2.1 序列的表示</h3><ul>
<li><p>可以使用cons构造序列，同时Scheme提供过程list用以快速构造序列：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(list &lt;a1&gt; &lt;a2&gt; ..) = (cons (a1 (cons a2 (cons ..))))</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用map过程，对一个list的所有元素进行操作映射。</p>
</li>
</ul>
<h3 id="2-2-2-层次性结构"><a href="#2-2-2-层次性结构" class="headerlink" title="2.2.2 层次性结构"></a>2.2.2 层次性结构</h3><p>使用list和cons可以构建复合形式的数据，我们可以将它看作树结构，进行递归访问。</p>
<h3 id="2-2-3-序列作为一种约定的界面"><a href="#2-2-3-序列作为一种约定的界面" class="headerlink" title="2.2.3 序列作为一种约定的界面"></a>2.2.3 序列作为一种约定的界面</h3><p>对于一个复杂的过程，我们可以将其拆分成一个信号流系统，将这个复杂的过程分割成不同的子过程，并且各个子过程之间用信号表示流动。<br>例：给定一个树，计算值为奇数的叶子的平方和。最原始的思想解题过程如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(define (sum-odd-squares tree)</span><br><span class="line">  (cond ((null? tree) 0)</span><br><span class="line">        ((not (pair? tree))</span><br><span class="line">         (if (odd? tree)</span><br><span class="line">             (square tree)</span><br><span class="line">             0))</span><br><span class="line">        (else (+ (sum-odd-squares (car tree))</span><br><span class="line">                 (sum-odd-squares (cdr tree))))))</span><br></pre></td></tr></table></figure></p>
<p>我们可以将上面这个复杂的过程归纳为信号流结构：</p>
<ol>
<li>枚举出一棵树的每个树叶</li>
<li>过滤它们，选出其中的奇数树叶</li>
<li>对选出的每一个数求平方</li>
<li>用+累加起来得到结果，从0开始</li>
</ol>
<p>但在上面的原始过程中，我们并没有体现出信号流结构。我们需要重新组织这些程序，使之能够清晰的反应上面信号流的结构，其中最关键的一点就是将注意力集中在处理过程中从一个步骤流向下一个步骤的“信号”。   </p>
<ul>
<li><p>枚举一棵树的所有树叶：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(define (enumerate-tree tree)</span><br><span class="line">  (cond ((null? tree) nil)</span><br><span class="line">        ((not (pair? tree)) (list tree))</span><br><span class="line">        (else (append (enumerate-tree (car tree))</span><br><span class="line">                      (enumerate-tree (cdr tree))))))</span><br><span class="line"></span><br><span class="line">(enumerate-tree (list 1 (list 2 (list 3 4)) 5))</span><br><span class="line">(1 2 3 4 5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照给定谓词过滤元素：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(define (filter predicate sequence)</span><br><span class="line">  (cond ((null? sequence) nil)</span><br><span class="line">        ((predicate (car sequence))</span><br><span class="line">         (cons (car sequence)</span><br><span class="line">               (filter predicate (cdr sequence))))</span><br><span class="line">        (else (filter predicate (cdr sequence)))))</span><br><span class="line"></span><br><span class="line">(filter odd? (list 1 2 3 4 5))</span><br><span class="line">(1 3 5)</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现信号流图中的映射步骤：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(map square (list 1 2 3 4 5))</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现流图中的累加过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define (accumulate op initial sequence)</span><br><span class="line">  (if (null? sequence)</span><br><span class="line">      initial</span><br><span class="line">      (op (car sequence)</span><br><span class="line">          (accumulate op initial (cdr sequence)))))</span><br></pre></td></tr></table></figure>
</li>
<li><p>最后，将整个流程整合起来形成一个过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(define (sum-odd-squares tree)</span><br><span class="line">  (accumulate +</span><br><span class="line">              0</span><br><span class="line">              (map square</span><br><span class="line">                   (filter odd?</span><br><span class="line">                           (enumerate-tree tree)))))</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将程序表示为一些针对序列的操作，这样做的价值就在于能帮助我们得到模块化的程序设计，也就是说，得到由一些比较独立的片段的组合构成的设计。在工业设计中，模块化结构是控制复杂性的一种威力强大的策略。</p>
<h3 id="2-2-4-实例分析：一个图形语言"><a href="#2-2-4-实例分析：一个图形语言" class="headerlink" title="2.2.4 实例分析：一个图形语言"></a>2.2.4 实例分析：一个图形语言</h3><p>在描述一种语言时，应该将注意力集中到语言的基本原语，它的组合手段以及它的抽象手段。详细内容见书P86.</p>
<h2 id="2-3-符号数据"><a href="#2-3-符号数据" class="headerlink" title="2.3 符号数据"></a>2.3 符号数据</h2><p>到目前为止，我们已经使用过的所有复合数据都是从数值出发构造起来的，在这一节，我们要扩充所用语言的表述能力，引进将任意符号作为数据的功能。</p>
<h3 id="2-3-1-使用引号表示字符"><a href="#2-3-1-使用引号表示字符" class="headerlink" title="2.3.1 使用引号表示字符"></a>2.3.1 使用引号表示字符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(define a 1)</span><br><span class="line">(define b 2)</span><br><span class="line">(list a b)</span><br><span class="line">&gt;&gt;(1 2)</span><br><span class="line">(list &apos;a &apos;b)</span><br><span class="line">&gt;&gt;(a b)</span><br><span class="line">(list &apos;a b)</span><br><span class="line">&gt;&gt;(a 2)</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/18/Hadoop入门/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/18/Hadoop入门/" itemprop="url">Hadoop入门</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-18T00:00:00+09:00">
                2018-04-18
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="大数据的三个‘V’："><a href="#大数据的三个‘V’：" class="headerlink" title="大数据的三个‘V’："></a>大数据的三个‘V’：</h2><ul>
<li>volume 数据量非常大</li>
<li>variety 数据有各种来源，也就导致了数据以各种形式存储</li>
<li>velocity 系统可能需要以非常快的速度接受数据，所以存储速度和处理速度都非常重要</li>
</ul>
<h2 id="Hadoop核心"><a href="#Hadoop核心" class="headerlink" title="Hadoop核心"></a>Hadoop核心</h2><ol>
<li><p>HDFS文件存储系统</p>
</li>
<li><p>MapReduce数据处理系统</p>
</li>
</ol>
<h2 id="Hadoop生态"><a href="#Hadoop生态" class="headerlink" title="Hadoop生态"></a>Hadoop生态</h2><ol>
<li>Hive和Pig 可以让开发人员在不懂编程语言的情况下用SQL等关系数据库模型使用Hadoop。 Hive和Pig的解释器会将SQL-like的代码转换为MapReduce代码对cluster进行操作。</li>
<li>Impala 可以直接access到cluster with SQL，而不用编译为MapReduce代码，所以Impala运行非常快速</li>
<li>Sqoop 可以将存储在传统关系型数据库上的数据转换到HDFS中。</li>
<li>Flume 基本上同上</li>
<li>Hbase  a real time database, built on top of HDFS</li>
</ol>
<h2 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h2><ul>
<li>文件载入到HDFS时，HDFS会自动将大文件切割成一个个block，每个64MB，每个block会有一个独特的名字BLK_n，每个block会被存储在cluster中的各个DataNode上，同时，有一个MetaData存储在名为NameNode的节点，该data存储每个文件的组成block的路径</li>
<li>为了防止每个节点上的数据损坏导致整个原始大数据文件损坏，HDFS会将每个block复制三份并存储在不同的节点上。</li>
<li>为了防止NameNode上的MetaData损坏导致整个cluster上存储的文件不可读，HDFS有HFS技术，即使NameNode损坏，MetaData也被HFS存储在network上的其他地方。</li>
</ul>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><ul>
<li>MapReduce处理数据 in parallel</li>
<li>mapper将并行处理一个个小数据，并输出intermediate records</li>
<li>Hadoop以key-value形式存储所有数据</li>
<li>Shuffle and Sort 会将mapper的输出传递给reduce</li>
<li>reduce会对输入进行进一步计算，给出最终结果</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/16/sklearn学习笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/16/sklearn学习笔记/" itemprop="url">sklearn学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-16T00:00:00+09:00">
                2018-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Sklearn简介"><a href="#Sklearn简介" class="headerlink" title="Sklearn简介"></a>Sklearn简介</h2><p>Sklearn是机器学习领域最知名的python模块之一，广泛的应用到各种机器学习项目中。如果英语足够好的话，可以查看Skearn官网，那里有你想知道的一切。<br><a href="http://scikit-learn.org/stable/" target="_blank" rel="noopener">http://scikit-learn.org/stable/</a><br>Sklearn包含了多种机器学习方式：</p>
<ul>
<li>Classification分类</li>
<li>Regression回归</li>
<li>Clustering非监督聚类</li>
<li>Dimensionality reduction数据降维</li>
<li>Preprocessing数据预处理</li>
</ul>
<h2 id="Sklearn安装"><a href="#Sklearn安装" class="headerlink" title="Sklearn安装"></a>Sklearn安装</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux可以直接使用pip进行安装，方便快捷。需要说明的是，sklearn需要Numpy和Scipy模块的支持。也就是说，在安装sklearn前，需要确定电脑已经安装了依赖模块。</p>
<h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>windows安装建议通过Anaconda来安装所有科学计算需要的模块，方便快捷。</p>
<h2 id="Sklearn模型选择"><a href="#Sklearn模型选择" class="headerlink" title="Sklearn模型选择"></a>Sklearn模型选择</h2><p>在官网上，有一个机器学习模型选择流程图，在进行机器学习模型选择时可以用作参考：<br><a href="http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html" target="_blank" rel="noopener">http://scikit-learn.org/stable/tutorial/machine_learning_map/index.html</a></p>
<h2 id="Sklearn初探"><a href="#Sklearn初探" class="headerlink" title="Sklearn初探"></a>Sklearn初探</h2><p>Sklearn把所有及其模型的使用模式整合在了一起，所有模型的调用方式都是一样的。也就是说，学会了一种机器学习模型的使用方法，也就掌握了所有模型的使用方式。</p>
<h3 id="K近邻方法"><a href="#K近邻方法" class="headerlink" title="K近邻方法"></a>K近邻方法</h3><p>让我们使用Sklearn自带的数据集，使用k近邻算法，探索Sklearn模块的使用模式：</p>
<ol>
<li><p>首先导入包：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import datasets</span><br><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br></pre></td></tr></table></figure>
</li>
<li><p>载入数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iris = datasets.load_iris()</span><br><span class="line">iris_X = iris.data</span><br><span class="line">iris_y = iris.target</span><br><span class="line"></span><br><span class="line">print(iris_X[:3,:])</span><br><span class="line">print(iris_y[:3])</span><br></pre></td></tr></table></figure>
</li>
<li><p>训练数据集测试数据集分离并训练K近邻模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">X_train, X_test, y_train, y_test = train_test_split(iris_X, iris_y, test_size=0.3)</span><br><span class="line"></span><br><span class="line">kNN = KNeighborsClassifier()</span><br><span class="line">kNN.fit(X_train, y_train)</span><br></pre></td></tr></table></figure>
</li>
<li><p>预测和评分：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prediction = kNN.predict(X_test)</span><br><span class="line">score = kNN.score(X_test, y_test)#分类准确率</span><br><span class="line">probability = kNN.predict_proba(X_test)</span><br><span class="line">neighborpoint=knn.kneighbors(iris_x_test[-1],5,False)</span><br><span class="line">#计算与最后一个测试样本距离在最近的5个点，返回的是这些样本的序号组成的数组</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="模型常用属性和功能"><a href="#模型常用属性和功能" class="headerlink" title="模型常用属性和功能"></a>模型常用属性和功能</h2><h3 id="训练和预测"><a href="#训练和预测" class="headerlink" title="训练和预测"></a>训练和预测</h3><p>如上文代码所示：</p>
<ul>
<li>model.fit(x_train, y_labels)可以对模型进行训练</li>
<li>model.predict(x_test)使用训练好的模型进行预测</li>
<li>每个模型在训练和预测时，都有非常多的参数可以调整，对于新手来说，可以直接使用默认参数。当熟练掌握模型后，可以通过对参数的调整来优化模型。</li>
</ul>
<h3 id="模型参数"><a href="#模型参数" class="headerlink" title="模型参数"></a>模型参数</h3><p>Sklearn对每个模型都提供方法，用以取出模型的具体参数信息：</p>
<ul>
<li>model.coef_, model.intercept_就属于model的属性。例如对线性回归来说，这两个参数分别代表模型的斜率和截距。</li>
<li>model.get_params()函数可以返回在模型定义时，定义的参数。</li>
</ul>
<h3 id="预测评分"><a href="#预测评分" class="headerlink" title="预测评分"></a>预测评分</h3><ul>
<li>model.score(x_test, y_test)可以输出模型对测试集合的预测评分。</li>
</ul>
<p>以上就是最常见的模型使用方法：1.创建模型 2.训练模型 3.预测/测试模型</p>
<h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>Sklearn提供便捷强大的数据预处理模块，方便工程师对数据进行快速处理</p>
<h4 id="数据标准化"><a href="#数据标准化" class="headerlink" title="数据标准化"></a>数据标准化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import preprocessing</span><br><span class="line">data = preprocessing.scale(data)</span><br></pre></td></tr></table></figure>
<h2 id="常用机器学习模型"><a href="#常用机器学习模型" class="headerlink" title="常用机器学习模型"></a>常用机器学习模型</h2><h3 id="k近邻"><a href="#k近邻" class="headerlink" title="k近邻"></a>k近邻</h3><p>sklearn.neighbors封装了所有与k近邻相关的算法模型，包括非监督kNN，分类kNN，回归kNN，以及kNN等几个实现算法等</p>
<h4 id="常用参数："><a href="#常用参数：" class="headerlink" title="常用参数："></a>常用参数：</h4><ul>
<li>n_neighbors：kNN中的k值</li>
<li>radius：限定半径最近邻中的半径</li>
<li>algorithm：实现算法，提供’ball_tree’, ‘kd_tree’, ‘auto’, ‘brute’</li>
<li>metric：距离度量方法，提供’euclidean’, ‘manhattan’, ‘chebyshev’, ‘minkowski’等，一般使用默认欧式距离<h4 id="非监督k近邻"><a href="#非监督k近邻" class="headerlink" title="非监督k近邻"></a>非监督k近邻</h4>‘from sklearn.neighbors import NearestNeighbors’</li>
</ul>
<h4 id="分类kNN"><a href="#分类kNN" class="headerlink" title="分类kNN"></a>分类kNN</h4><p>‘from sklearn.neighbors import KNeighborsClassifier’</p>
<h4 id="回归kNN"><a href="#回归kNN" class="headerlink" title="回归kNN"></a>回归kNN</h4><p>‘from sklearn.neighbors import KNeighborsRegressor’</p>
<h4 id="实现算法"><a href="#实现算法" class="headerlink" title="实现算法"></a>实现算法</h4><p>‘from sklearn.neighbors import KDTree’<br>‘from sklearn.neighbors import BallTree’</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/04/12/Python装饰器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/12/Python装饰器/" itemprop="url">python装饰器</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-04-12T00:00:00+09:00">
                2018-04-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="python装饰器"><a href="#python装饰器" class="headerlink" title="python装饰器"></a>python装饰器</h1><p>装饰器类似于java中的面向切面编程，可以将各个函数中重复的操作（插入日志，性能测试，事务处理，缓存等）抽离出来，将这些于函数原本功能无关的雷同代码定义在装饰器中，概括的讲： <strong>装饰器的作用就是为已经存在的对象添加额外的功能</strong></p>
<h2 id="装饰器简单应用"><a href="#装饰器简单应用" class="headerlink" title="装饰器简单应用"></a>装饰器简单应用</h2><p>看如下代码：decorator函数即定义一个装饰器，foo为一个常规的函数。该代码即为用decorator对f函数进行装饰。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def decorator(func):</span><br><span class="line">	def wrapper():</span><br><span class="line">		print(&apos;this is a decorator&apos;)</span><br><span class="line">		return func()</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">def func():</span><br><span class="line">	print(&apos;i am a normal function&apos;)</span><br><span class="line"></span><br><span class="line">foo = decorator(foo)</span><br><span class="line">foo()</span><br><span class="line"># 调用装饰过得foo函数会首先运行wrapper()中的内容，然后返回foo函数</span><br></pre></td></tr></table></figure></p>
<h2 id="装饰器的语法糖"><a href="#装饰器的语法糖" class="headerlink" title="装饰器的语法糖"></a>装饰器的语法糖</h2><p>在上面对装饰器的简单实用中，我们发现每次想要对函数进行装饰时，都需要进行一步赋值操作 ‘foo = decorator(foo)’，这种操作让程序变得更为复杂难以调试，所以我们可以使用语法糖完成对函数进行装饰的过程。</p>
<p>将装饰器的语法糖‘@’放到函数定义的地方，这样就可以省略最后一步的赋值操作。可以将上面的例子改写为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def decorator(func):</span><br><span class="line">	def wrapper():</span><br><span class="line">		print(&apos;this is a decorator&apos;)</span><br><span class="line">		return func()</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def foo():</span><br><span class="line">	print(&apos;i am a normal func&apos;)</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure></p>
<p>如上所示，使用语法糖，我们就可以省略最后一步的赋值操作。foo函数不需要作任何修改，只需要在定义函数的地方加上装饰器的语法糖，调用的时候还是和以前一样。</p>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><p>以上只是对装饰器最简单的应用，在现实应用中，业务逻辑函数会更加复杂，如果业务逻辑函数foo需要参数，这样在装饰器中我们似乎是需要修改参数，但通过在装饰器定义可变参数，可以更加便捷的实现该功能。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def decorator(func):</span><br><span class="line">	def wrapper(*args):</span><br><span class="line">		print(&apos;this is a decorator&apos;)</span><br><span class="line">		return func(*args)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def foo(name, age)</span><br><span class="line">  print(&apos;....&apos;)</span><br></pre></td></tr></table></figure></p>
<p>这样以来，不管业务函数需要多少个参数，我们都不需要对装饰器进行过多的更改。<br>同时，如果在业务逻辑函数中存在指定关键字参数。我们可以在wrapper中定义指定关键字参数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def decorator(func):</span><br><span class="line">	def wrapper(*args, **kargs):</span><br><span class="line">		print(&apos;this is a decorator&apos;)</span><br><span class="line">		return func(*args, **kargs)</span><br><span class="line">	return wrapper</span><br><span class="line"></span><br><span class="line">@decorator</span><br><span class="line">def foo(name, age, height=None)</span><br><span class="line">  print(&apos;....&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h2><p>在装饰器中，如果对传入的不同业务逻辑函数需要作不同的装饰，可以在业务逻辑函数定义使用装饰器语法糖时指定参数，从而达到在装饰器中分别处理的目的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">def use_logging(level):</span><br><span class="line">    def decorator(func):</span><br><span class="line">        def wrapper(*args, **kwargs):</span><br><span class="line">            if level == &quot;warn&quot;:</span><br><span class="line">                logging.warn(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">            elif level == &quot;info&quot;:</span><br><span class="line">                logging.info(&quot;%s is running&quot; % func.__name__)</span><br><span class="line">            return func(*args)</span><br><span class="line">        return wrapper</span><br><span class="line"></span><br><span class="line">    return decorator</span><br><span class="line"></span><br><span class="line">@use_logging(level=&quot;warn&quot;)</span><br><span class="line">def foo(name=&apos;foo&apos;):</span><br><span class="line">    print(&quot;i am %s&quot; % name)</span><br></pre></td></tr></table></figure></p>
<p>上面的 use logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=”warn”)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。<br>@use_logging(level=”warn”)等价于@decorator</p>
<h2 id="类装饰器"><a href="#类装饰器" class="headerlink" title="类装饰器"></a>类装饰器</h2><p>装饰器不仅仅是函数，也可以是类，使用类作为装饰器更加灵活强大。类装饰器主要依靠类的’<strong>call</strong>‘方法，当使用@形式将装饰器附加到函数上时，就会调用该方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Foo(object):</span><br><span class="line">  def __init__(self, func):</span><br><span class="line">    self._func = func</span><br><span class="line">  def __call__(self):</span><br><span class="line">    print(&apos;class decorator runing&apos;)</span><br><span class="line">    self._func()</span><br><span class="line">    print(&apos;class decorator ending&apos;)</span><br><span class="line"></span><br><span class="line">@Foo</span><br><span class="line">def bar():</span><br><span class="line">  print(&apos;bar&apos;)</span><br></pre></td></tr></table></figure></p>
<h2 id="装饰器顺序"><a href="#装饰器顺序" class="headerlink" title="装饰器顺序"></a>装饰器顺序</h2><p>对于一个函数，我们当然可以定义多个装饰器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@a</span><br><span class="line">@b</span><br><span class="line">@c</span><br><span class="line">def f():</span><br><span class="line">  pass</span><br></pre></td></tr></table></figure></p>
<p>这个函数的执行顺序是从里向外的，最先调用定义在最后的装饰器，等效于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = a(b(c(f)))</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/03/22/SICP第一章笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/22/SICP第一章笔记/" itemprop="url">SICP第一章:构造过程抽象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-03-22T00:00:00+09:00">
                2018-03-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-1-程序设计的基本元素"><a href="#1-1-程序设计的基本元素" class="headerlink" title="1.1 程序设计的基本元素"></a>1.1 程序设计的基本元素</h2><p>  一个优秀的程序设计语言，应该是一种框架，可以让程序员通过它自由的组织自己的计算思想。每一种强有力的语言都应该提供三个机制：</p>
<ul>
<li>基本表达形式：用于表示语言所关心的最简单的个体</li>
<li>组合的抽象方法：通过他们可以从较为简单的东西出发构造复杂的元素</li>
<li>抽象的方法：通过他们可以为复合对象命名，并将他们当作单元去操作<br>在程序设计中，我们需要处理两类要素：过程和数据，数据是一种我们希望去操作的东西，而过程就是有关操作浙西数据的规则描述。<h3 id="1-1-1-正则序求值和应用序求值"><a href="#1-1-1-正则序求值和应用序求值" class="headerlink" title="1.1.1 正则序求值和应用序求值"></a>1.1.1 正则序求值和应用序求值</h3><ul>
<li>对于一个复合计算过程，“完全展开而后归约”的求值模型称为正则序求值</li>
<li>“先求值参数而后应用”的方式，被称为应用序求值</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-牛顿法求平方根"><a href="#1-1-2-牛顿法求平方根" class="headerlink" title="1.1.2 牛顿法求平方根"></a>1.1.2 牛顿法求平方根</h3><p>如果对x的平方根的值有了一个猜测y，那么只需要求出y和x/y的平均值（它一定更接近实际的平方根值）。然后将得到的平均值作为下一个猜测，不断递归。</p>
<h3 id="1-1-3-过程作为黑箱的抽象"><a href="#1-1-3-过程作为黑箱的抽象" class="headerlink" title="1.1.3 过程作为黑箱的抽象"></a>1.1.3 过程作为黑箱的抽象</h3><p>对于一个复合过程，我们可以将其拆分成多个更小的子过程，而对于父过程而言，子过程即使一个个的黑箱，我们不需要知道子过程的具体实现过程，只需要知道子过程可以完成父过程需要的功能即可。<br><strong>按照过程抽象的思想编程，可以让我们更关注过程本身，至于子过程可以推后实现，相当于将过程解偶</strong></p>
<h3 id="1-1-4-局部子过程"><a href="#1-1-4-局部子过程" class="headerlink" title="1.1.4 局部子过程"></a>1.1.4 局部子过程</h3><p>对于一般子过程的定义，为了防止该子过程定义后与其他过程重名导致的混淆，应该将只被父过程调用的子过程定义在父过程的内部，即“块结构”。 在其它语言中，可以使用匿名函数，包命名管理等方法。</p>
<h2 id="1-3-用高阶函数作抽象"><a href="#1-3-用高阶函数作抽象" class="headerlink" title="1.3 用高阶函数作抽象"></a>1.3 用高阶函数作抽象</h2><p>如果一个编程语言将过程限制为只能作为以数作为抽象，那也会严重的限制我们建立抽象的能力。我们需要构造出这样的过程，让它们能以过程作为参数，或者以过程作为返回值。这类能操作过程的过程称为 <strong>高阶过程</strong></p>
<blockquote>
<p>函数式语言的设计的核心并不是仅仅想要将函数作为一切操作的核心，而是为了建立更高级，更广泛的过程抽象</p>
</blockquote>
<p><strong>let 表达式的一般形式</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(let ((&lt;var1&gt; &lt;exp1&gt;)</span><br><span class="line">      (&lt;var2&gt; &lt;exp2&gt;)</span><br><span class="line">      ...</span><br><span class="line">      )</span><br><span class="line">  &lt;body&gt;)</span><br></pre></td></tr></table></figure></p>
<h3 id="1-3-4-过程作为返回值"><a href="#1-3-4-过程作为返回值" class="headerlink" title="1.3.4 过程作为返回值"></a>1.3.4 过程作为返回值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(define (yahaha f)</span><br><span class="line">  (lambda (x) (f x x)))</span><br><span class="line"></span><br><span class="line">&gt;&gt;((yahaha *) 2)</span><br><span class="line">&gt;&gt; 4</span><br></pre></td></tr></table></figure>
<p>定义过程‘yahaha’，该过程会返回一个由lambda定义的过程，在该返回的过程中，会接收参数x，并返回(f x x)</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/02/11/atom运行python并修改为python3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/11/atom运行python并修改为python3/" itemprop="url">atom运行python3</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-02-11T00:00:00+09:00">
                2018-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>atom是一个由GitHub开发的开源编辑器，以往我是sublime的忠实粉丝，但sublime在Linux下不支持中文输入，没办法愉快的写注释了，只好投奔atom。该文介绍的是如何在atom下运行python。同时应为Mac的默认python版本为2.7，该文也会介绍如何修改atom的运行版本为python3</p>
<h2 id="下载script插件"><a href="#下载script插件" class="headerlink" title="下载script插件"></a>下载script插件</h2><p>点击左上角“Atom” -&gt; “preference” -&gt; “install”，在搜索框输入“script”下载安装script运行插件。下载完成后，我们可以新建一个py文件进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">print(sys.version)</span><br></pre></td></tr></table></figure></p>
<p>运行快捷键：Mac：”command + i”，我们可以看到，控制台输出的python版本为2.7，如果python2.7刚好满足你的日常编程需要，到此atom运行python就搞定了。</p>
<h2 id="修改python3"><a href="#修改python3" class="headerlink" title="修改python3"></a>修改python3</h2><p>如果你使用的是python3，那么需要修改一下atom的默认python运行版本。点击左上角atom：<br>preference –&gt; Open Config Folder –&gt; packages –&gt; lib –&gt; grammars –&gt; python.coffee<br>可以看到：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">exports.Python =</span><br><span class="line">  &apos;Selection Based&apos;:</span><br><span class="line">    command: &apos;python3&apos;</span><br><span class="line">    args: (context) -&gt; [&apos;-u&apos;, &apos;-c&apos;, context.getCode()]</span><br><span class="line"></span><br><span class="line">  &apos;File Based&apos;:</span><br><span class="line">    command: &apos;python3&apos;</span><br><span class="line">    args: (&#123;filepath&#125;) -&gt; [&apos;-u&apos;, filepath]</span><br></pre></td></tr></table></figure></p>
<p>修改command: ‘python’ 为 “python3” 即可（本文已经进行修改）</p>
<h2 id="python2和python3并存"><a href="#python2和python3并存" class="headerlink" title="python2和python3并存"></a>python2和python3并存</h2><p>如果你是大部分时间需要python2，偶尔运行一下python3，那么往复修改配置文件就会显得麻烦，script插件可以配置多个运行环境满足该需求：</p>
<ul>
<li>点击上方“packages” -&gt; “Script” -&gt; “configure script”</li>
<li>到此会出现一个对话框，在“commend”输入python3即可，并‘run’一下，就会发现当前文件已经使用python3进行运行。</li>
<li>完成上述配置后，以后如果想要运行python3，可以使用快捷键：’command + shift + k’，就会出现你已经配置好的运行环境，再按一下回车就可以运行了。</li>
<li>默认的python2运行快捷键仍然是 “command + i”</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/04/Kaggle解题步骤/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Dongfang Li">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Black Feather">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/12/04/Kaggle解题步骤/" itemprop="url">Kaggle解题步骤</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-12-04T00:00:00+09:00">
                2017-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>最近为了提高ML项目能力，打算参加Kaggle比赛，虽然是孤军奋斗，但也收获颇多，现在总结了一下Kaggle解题流程，提供给大家一个大体的解题流程框架。</p>
<h1 id="解题流程"><a href="#解题流程" class="headerlink" title="解题流程"></a>解题流程</h1><h2 id="竞赛之前"><a href="#竞赛之前" class="headerlink" title="竞赛之前"></a>竞赛之前</h2><h4 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h4><p>在选择参加的赛题时候，需要先对赛题进行简单的分析，将其转化为机器学习问题，Kaggle中常见问题类型有：</p>
<ol>
<li>回归问题</li>
<li>分类问题（多分类，多标签）</li>
</ol>
<h4 id="数据理解"><a href="#数据理解" class="headerlink" title="数据理解"></a>数据理解</h4><p>同时也需要大概看一眼数据，确定对于自己来说，该问题是否可解（对于显卡渣来说，图像类竞赛还是早早放弃吧= =），而且有些金融类问题，数据集存在着大量的缺失，预测标签也存在较大偏差值，这类问题需要慎重，可能需要专业的金融知识进行特征工程。</p>
<h4 id="开始竞赛"><a href="#开始竞赛" class="headerlink" title="开始竞赛"></a>开始竞赛</h4><p>在确定对题目有较大信心，数据集合适后，那就开始Kaggle竞赛吧。</p>
<h2 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h2><h4 id="数据概览"><a href="#数据概览" class="headerlink" title="数据概览"></a>数据概览</h4><p>好了，现在开心的打开你的jupyter notebook，开始Kaggle之旅吧。在载入数据后，我们先要做的是对数据整体有个大概的认识：训练集和测试集都多大？有多少个属性？每个属性是什么类型的？属性是否有缺失值？数值型属性的分布情况（min，max，mean，meduim，std等统计值）？等等，有了这些信息，会让你在脑海里对数据有个大体的认识，这是几个在这个环节常用的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">data.shape</span><br><span class="line">data.head()</span><br><span class="line">data.info()</span><br><span class="line">data.describe()</span><br><span class="line">data.isnull().sum()[data.isnull().sum()&gt;<span class="number">0</span>]</span><br></pre></td></tr></table></figure></p>
<h4 id="具体分析和可视化"><a href="#具体分析和可视化" class="headerlink" title="具体分析和可视化"></a>具体分析和可视化</h4><p>在我们对数据整体有个大体认识的情况下，针对每个特征，进行进一步的探索分析。在这个过程中，使用常见可视化工具，可以较为直观的展现数据。常见的可视化工具有：matplotlib和seaborn，其中，seaborn是对matplotlib的进一步封装，让工程师可以更加便捷的进行可视化，常见的可视化准则有：</p>
<ul>
<li>sns.jointplot(): 绘制属性随标签的变化趋势</li>
<li>sns.heatmap(data.corr()): 绘制热力图，可以对属性的相关性进行简单探索</li>
<li>sns.distplot(): 绘制分布图，可以展示连续自变量和标签的关系</li>
<li>sns.boxplot(): 绘制箱型图，适合用于探索取值较少的属性和标签的关系</li>
</ul>
<p>在对各个属性进行细致可视化观察过程中，需要记录下这个属性和标签的相关性，进而分析该属性是否是一个有价值的属性，并<br>在观察数据的过程中，需要思考一下几个问题：</p>
<ol>
<li>数据应该怎样清洗和处理才是合理的？离散化？连续化？</li>
<li>根据数据类型可以挖掘出什么特征？</li>
<li>数据中的哪些特征对预测有帮助？</li>
<li>（进阶）是否可以构造出新的特征？</li>
</ol>
<h2 id="特征工程"><a href="#特征工程" class="headerlink" title="特征工程"></a>特征工程</h2><p>特征是决定效果最关键的一环，利用人为先验知识，从数据中总结出特征。特征工程是整个项目中最重要的一环之一，好的特征工程决定了预测结果的上限，机器学习模型只是帮助你不断逼近这个上限而已。</p>
<h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><p>首先，对于刚拿到的数据，会出现噪声，离群点，缺失等问题，我们需要对数据进行清理和加工，对于不同类型的变量，有不同的处理方法：</p>
<ol>
<li>对于数值型变量，需要处理离散群点，缺失值，异常值等情况。</li>
<li>对于类别型变量，可以转化为one-hot编码。</li>
<li>文本数据较为复杂，文本中会有垃圾字符，错别字，数学公式，不统一度量衡日期格式等，包括标点符号，分词。对于英文文本可能还需要词性还原。</li>
</ol>
<h4 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h4><ul>
<li>我们应该尽可能多的抽取特征，只要是认为某个特征对解决问题有帮助，它就可以成为一个特征。</li>
<li>特征抽取需要不断迭代，最为耗费时间。</li>
<li>常见特征抽取方法：<ol>
<li>对于数值型特征，可以通过线性组合，多项式组合来发现新的特征。</li>
<li>对于文本数据，有一些常规的特征：文本长度，embeddings，TF-IDF，LDA等</li>
<li>如果对数据有更深刻的理解，可以试着构造magic feature。</li>
<li>通过错误分析也可以发现新的特征。</li>
</ol>
</li>
</ul>
<h4 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h4><ul>
<li>过多的特征会造成冗余，噪声，过拟合等问题。因此需要特征筛选，可以加快模型训练速度，提升效果。</li>
<li>特征选择方法多种多样，最简单的时相关度系数，用以衡量两个变量之间的线性关系。</li>
<li>可以通过分析构建相关系数矩阵。特征和标签之间的相关度可以看做该特征的重要度，特征与特征之间的相关度高，则说明这两个特征存在冗余。</li>
<li>也可以通过训练模型来筛选特征。</li>
</ul>
<h2 id="建模"><a href="#建模" class="headerlink" title="建模"></a>建模</h2><h4 id="机器学习模型"><a href="#机器学习模型" class="headerlink" title="机器学习模型"></a>机器学习模型</h4><p>机器学习模型很多，可以都做尝试，不仅可以测试效果，还可以学习各种模型技巧。常见模型：</p>
<pre><code>1. KNN
2. SVM
3. Linear Model
4. Extra Tree
5. RandomForest
6. Gradient Boost Tree
7. Neural Network
</code></pre><h4 id="调参"><a href="#调参" class="headerlink" title="调参"></a>调参</h4><p>在训练模型前，我们已经预设了一些模型参数（比如树的深度）和优化过程（比如学习率）。这种参数被称为超参。</p>
<p>调参虽然被称为一门玄学，但还是有些章法可寻：</p>
<pre><code>1. 根据经验，选出对模型效果影响最大的超参
2. 按照经验设置超参的搜索空间，比如学习率：[0.0001, 0.1]
3. 选择搜索算法
4. 验证模型的泛化能力
</code></pre><p>同时，也可以用可视化工具将不同参数模型在测试集的效果可视化，进而选择最优的参数。</p>
<h4 id="模型验证"><a href="#模型验证" class="headerlink" title="模型验证"></a>模型验证</h4><ul>
<li>简单分割</li>
<li>交叉验证<ol>
<li>将整个训练数据随机分成k份，训练k个moxing，取k-1份train，1份valid。</li>
<li>也叫k-fold</li>
<li>k一般选值在3到10之间</li>
</ol>
</li>
</ul>
<h4 id="错误分析"><a href="#错误分析" class="headerlink" title="错误分析"></a>错误分析</h4><ul>
<li>每个模型都会犯一些错误，为了了解模型在犯什么错误，我们可以观察被误判的样本，总结他们的共同特征，就可以再训练一个效果更好的模型。</li>
<li>错误分析-&gt;发现新特征-&gt;训练新模型-&gt;错误分析。 可以不断迭代出更好的效果。</li>
</ul>
<h4 id="模型集成"><a href="#模型集成" class="headerlink" title="模型集成"></a>模型集成</h4><p>我们可以使用模型集成方法，将多个ML模型集成到一起，最后我们可以综合考虑所有ML模型的预测结果，进而可以给出一个更加准确的预测。</p>
<ul>
<li>常见方法有：bagging, boosting, stacking, blending.</li>
<li>bagging<ol>
<li>bagging是将多个模型的预测结果简单地加权平均或者投票，bagging的好处在于可以并行的训练基学习器。</li>
<li>bagging通常没有一个明确的优化目标。</li>
</ol>
</li>
<li>Boosting<ol>
<li>Boosting思想接近于知错能改，每训练一个基学习器，是为了弥补上一个基学习器所犯的错误。</li>
<li>著名算法有：AdaBoost，GradientBoost</li>
</ol>
</li>
<li>Stacking<ol>
<li>是用新的模型（次学习器）去学习怎么组合基学习器。</li>
<li>Stacking的思想是多个基学习器的加权非线性组合</li>
</ol>
</li>
<li>Blending</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Kaggle项目是一个不断往复的过程，正如吴恩达在《Machine Learning》课上所说，对于机器学习项目，我们首先做出一个非常简单粗暴的模型，这个模型的准确率往往是欠佳的，而我们接下来要做的就是不断优化我们的模型，不断修改特征工程，提炼出更好的模型，更好的特征，进而不断提高预测准确率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Dongfang Li</p>
              <p class="site-description motion-element" itemprop="description">My blog about programming and machine learning</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Dongfang Li</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
